// Copyright (c) Lucas Girouard-Stranks (https://github.com/lithiumtoast). All rights reserved.
// Licensed under the MIT license. See LICENSE file in the Git repository root directory for full license information.

using System;
using System.Collections.Immutable;
using System.Linq;
using C2CS.Bindgen.Languages.CSharp;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Formatting;
using static Microsoft.CodeAnalysis.CSharp.SyntaxFactory;

namespace C2CS.UseCases.BindgenCSharp
{
	public class CSharpCodeGenerator
	{
		public readonly string ClassName;
		public readonly string LibraryName;

		public CSharpCodeGenerator(Configuration configuration)
		{
			ClassName = configuration.ClassName;
			LibraryName = configuration.LibraryName;
		}

		public string EmitCode(CSharpAbstractSyntaxTree abstractSyntaxTree)
		{
			var builder = ImmutableArray.CreateBuilder<MemberDeclarationSyntax>();

			EmitVirtualTable(builder, abstractSyntaxTree.VariablesExtern);

			EmitVariableProperties(builder, abstractSyntaxTree.VariablesExtern);
			EmitMethodsExterns(builder, abstractSyntaxTree.FunctionExterns);
			EmitFunctionPointers(builder, abstractSyntaxTree.FunctionPointers);
			EmitStructs(builder, abstractSyntaxTree.Structs);
			EmitOpaqueDataTypes(builder, abstractSyntaxTree.OpaqueDataTypes);
			EmitTypedefs(builder, abstractSyntaxTree.Typedefs);
			EmitEnums(builder, abstractSyntaxTree.Enums);

			var membersToAdd = builder.ToArray();
			var compilationUnit = EmitCompilationUnit(
				ClassName,
				LibraryName,
				membersToAdd);
			return compilationUnit.ToFullString();
		}

		private static CompilationUnitSyntax EmitCompilationUnit(
			string className,
			string libraryName,
			MemberDeclarationSyntax[] members)
		{
			var code = $@"
//-------------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by the following tool:
//        https://github.com/lithiumtoast/c2cs
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ReSharper disable All
//-------------------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Runtime.CompilerServices;

#nullable enable

public static unsafe partial class {className}
{{
    private const string LibraryName = ""{libraryName}"";
	private static IntPtr _libraryHandle;

	public static void LoadApi(string? libraryFilePath = null)
	{{
		UnloadApi();
		if (libraryFilePath == null)
		{{
			var libraryFileNamePrefix = Runtime.LibraryFileNamePrefix;
			var libraryFileNameExtension = Runtime.LibraryFileNameExtension;
			libraryFilePath = $@""{{libraryFileNamePrefix}}{{LibraryName}}{{libraryFileNameExtension}}"";
		}}
		_libraryHandle = Runtime.LibraryLoad(libraryFilePath);
		if (_libraryHandle == IntPtr.Zero) throw new Exception($""Failed to load library: {{libraryFilePath}}"");
		_LoadVirtualTable();
	}}

	public static void UnloadApi()
	{{
		if (_libraryHandle == IntPtr.Zero) return;
		_UnloadVirtualTable();
		Runtime.LibraryUnload(_libraryHandle);
	}}
}}
";

			var syntaxTree = ParseSyntaxTree(code);
			var compilationUnit = syntaxTree.GetCompilationUnitRoot();
			var @class = (ClassDeclarationSyntax)compilationUnit.Members[0];

			var newClass = @class.AddMembers(members);
			var newCompilationUnit = compilationUnit.ReplaceNode(@class, newClass);

			var workspace = new AdhocWorkspace();
			var newCompilationUnitFormatted = (CompilationUnitSyntax)Formatter.Format(newCompilationUnit, workspace);

			return newCompilationUnitFormatted;
		}

		private static void EmitVirtualTable(
			ImmutableArray<MemberDeclarationSyntax>.Builder builder,
			ImmutableArray<CSharpVariable> variablesExtern)
		{
			var loaderStatementStrings = variablesExtern.Select(x =>
				@$"_{x.Name} = Runtime.LibraryGetExport(_libraryHandle, ""{x.Name}"");");
			var loadStatements = string.Join('\n', loaderStatementStrings);

			var loadCode = $@"
private static void _LoadVirtualTable()
{{
	{loadStatements}
}}
";

			var loadMember = ParseMemberDeclaration(loadCode)!;
			if (loadMember is MethodDeclarationSyntax loadSyntax)
			{
				builder.Add(loadSyntax);
			}
			else
			{
				var up = new CSharpCodeGenerationException("Error generating C# virtual table.");
				throw up;
			}

			var unloadStatementStrings = variablesExtern.Select(x =>
				@$"_{x.Name} = IntPtr.Zero;");
			var unloadStatements = string.Join('\n', unloadStatementStrings);

			var code = $@"
private static void _UnloadVirtualTable()
{{
	{unloadStatements}
}}
";

			var unloadMember = ParseMemberDeclaration(code)!;
			if (unloadMember is MethodDeclarationSyntax unloadSyntax)
			{
				builder.Add(unloadSyntax);
			}
			else
			{
				var up = new CSharpCodeGenerationException("Error generating C# virtual table.");
				throw up;
			}
		}

		private static void EmitVariableProperties(
			ImmutableArray<MemberDeclarationSyntax>.Builder builder,
			ImmutableArray<CSharpVariable> variablesExtern)
		{
			foreach (var variableExtern in variablesExtern)
			{
				var field = EmitVariablePropertyBackingField(variableExtern);
				builder.Add(field);

				var method = EmitVariableProperty(variableExtern);
				builder.Add(method);
			}
		}

		private static FieldDeclarationSyntax EmitVariablePropertyBackingField(CSharpNode @extern)
		{
			var code = $@"
{@extern.CodeLocationComment}
private static IntPtr _{@extern.Name};
".TrimEnd();

			var member = (FieldDeclarationSyntax)ParseMemberDeclaration(code)!;
			return member;
		}

		private static MemberDeclarationSyntax EmitVariableProperty(CSharpVariable variable)
		{
			var code = $@"
public static {variable.Type.Name} {variable.Name}
{{
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	get => Runtime.ReadMemory<{variable.Type.Name}>(_{variable.Name});
}}
";

			var result = ParseMemberDeclaration(code);
			if (result != null)
			{
				return result;
			}

			var up = new GeneratorUnexpectedException(variable);
			throw up;
		}

		private static void EmitMethodsExterns(
			ImmutableArray<MemberDeclarationSyntax>.Builder builder,
			ImmutableArray<CSharpFunction> functionExterns)
		{
			foreach (var functionExtern in functionExterns)
			{
				// https://github.com/lithiumtoast/c2cs/issues/15
				var shouldIgnore = false;
				foreach (var cSharpFunctionExternParameter in functionExtern.Parameters)
				{
					if (cSharpFunctionExternParameter.Type.Name == "va_list")
					{
						shouldIgnore = true;
						break;
					}
				}

				if (shouldIgnore)
				{
					continue;
				}

				var member = EmitMethod(functionExtern);
				builder.Add(member);
			}
		}

		private static MethodDeclarationSyntax EmitMethod(CSharpFunction function)
		{
			var parameterStrings = function.Parameters.Select(
				x => $@"{x.Type.Name} {x.Name}");
			var parameters = string.Join(',', parameterStrings);

			var code = $@"
{function.CodeLocationComment}
[DllImport(LibraryName, EntryPoint = ""{function.Name}"", CallingConvention = CallingConvention.{function.CallingConvention})]
public static extern {function.ReturnType.Name} {function.Name}({parameters});
";

			var member = ParseMemberDeclaration(code)!;
			if (member is MethodDeclarationSyntax syntax)
			{
				return syntax;
			}

			var up = new CSharpCodeGenerationException("Error generating C# extern method.");
			throw up;
		}

		private static void EmitFunctionPointers(
			ImmutableArray<MemberDeclarationSyntax>.Builder builder,
			ImmutableArray<CSharpFunctionPointer> functionPointers)
		{
			foreach (var functionPointer in functionPointers)
			{
				var member = EmitFunctionPointer(functionPointer);
				builder.Add(member);
			}
		}

		public static StructDeclarationSyntax EmitFunctionPointer(
			CSharpFunctionPointer functionPointer, bool isNested = false)
		{
			var parameterStrings = functionPointer.Parameters
				.Select(x => $"{x.Type}").Append($"{functionPointer.ReturnType.Name}");
			var parameters = string.Join(',', parameterStrings);

			var code = $@"
{functionPointer.CodeLocationComment}
[StructLayout(LayoutKind.Sequential)]
public struct {functionPointer.Name}
{{
	public delegate* unmanaged <{parameters}> Pointer;
}}
";

			if (isNested)
			{
				code = code.Trim();
			}

			var member = ParseMemberDeclaration(code)!;
			if (member is StructDeclarationSyntax syntax)
			{
				return syntax;
			}

			var up = new CSharpCodeGenerationException("Error generating C# pointer function.");
			throw up;
		}

		private static void EmitStructs(
			ImmutableArray<MemberDeclarationSyntax>.Builder builder,
			ImmutableArray<CSharpStruct> structs)
		{
			foreach (var @struct in structs)
			{
				var member = EmitStruct(@struct);
				builder.Add(member);
			}
		}

		private static StructDeclarationSyntax EmitStruct(CSharpStruct @struct, bool isNested = false)
		{
			var memberSyntaxes = EmitStructMembers(
				@struct.Name, @struct.Fields, @struct.NestedStructs, @struct.NestedFunctionPointers);
			var memberStrings = memberSyntaxes.Select(x => x.ToFullString());
			var members = string.Join("\n\n", memberStrings);

			var code = $@"
{@struct.CodeLocationComment}
[StructLayout(LayoutKind.Explicit, Size = {@struct.Type.SizeOf}, Pack = {@struct.Type.AlignOf})]
public struct {@struct.Name}
{{
	{members}
}}
";

			if (isNested)
			{
				code = code.Trim();
			}

			var member = ParseMemberDeclaration(code)!;
			if (member is StructDeclarationSyntax syntax)
			{
				return syntax;
			}

			var up = new CSharpCodeGenerationException("Error generating C# struct.");
			throw up;
		}

		private static MemberDeclarationSyntax[] EmitStructMembers(
			string structName,
			ImmutableArray<CSharpStructField> fields,
			ImmutableArray<CSharpStruct> nestedStructs,
			ImmutableArray<CSharpFunctionPointer> nestedFunctionPointers)
		{
			var builder = ImmutableArray.CreateBuilder<MemberDeclarationSyntax>();

			foreach (var field in fields)
			{
				if (!field.Type.IsArray)
				{
					var fieldMember = EmitStructField(field);
					builder.Add(fieldMember);
				}
				else
				{
					var fieldMember = EmitStructFieldFixedBuffer(field);
					builder.Add(fieldMember);

					var methodMember = EmitStructFieldFixedBufferProperty(
						structName, field);
					builder.Add(methodMember);
				}
			}

			foreach (var nestedStruct in nestedStructs)
			{
				var syntax = EmitStruct(nestedStruct, true);
				builder.Add(syntax);
			}

			foreach (var nestedFunctionPointer in nestedFunctionPointers)
			{
				var syntax = EmitFunctionPointer(nestedFunctionPointer, true);
				builder.Add(syntax);
			}

			var structMembers = builder.ToArray();
			return structMembers;
		}

		private static FieldDeclarationSyntax EmitStructField(CSharpStructField field)
		{
			var code = $@"
[FieldOffset({field.Offset})] // size = {field.Type.SizeOf}, padding = {field.Padding}
public {field.Type.Name} {field.Name};
".Trim();

			var member = ParseMemberDeclaration(code)!;
			if (member is FieldDeclarationSyntax syntax)
			{
				return syntax;
			}

			var up = new CSharpCodeGenerationException("Error generating C# field.");
			throw up;
		}

		private static FieldDeclarationSyntax EmitStructFieldFixedBuffer(
			CSharpStructField field)
		{
			string typeName;

			if (field.IsWrapped)
			{
				typeName = field.Type.AlignOf switch
				{
					1 => "byte",
					2 => "ushort",
					4 => "uint",
					8 => "ulong",
					_ => throw new InvalidOperationException()
				};
			}
			else
			{
				typeName = field.Type.Name;
			}

			var code = $@"
[FieldOffset({field.Offset})] // size = {field.Type.SizeOf}, padding = {field.Padding}
public fixed {typeName} _{field.Name}[{field.Type.SizeOf}/{field.Type.AlignOf}]; // {field.Type.OriginalName}
".Trim();

			var member = (FieldDeclarationSyntax)ParseMemberDeclaration(code)!;
			return member;
		}

		private static PropertyDeclarationSyntax EmitStructFieldFixedBufferProperty(
			string structName,
			CSharpStructField field)
		{
			var fieldTypeName = field.Type.Name;
			if (fieldTypeName == "void*")
			{
				fieldTypeName = "IntPtr";
			}

			var code = $@"
public Span<{fieldTypeName}> {field.Name}
{{
	get
	{{
		fixed ({structName}*@this = &this)
		{{
			var pointer = &@this->_{field.Name}[0];
			var span = new Span<{fieldTypeName}>(pointer, {field.Type.ArraySize});
			return span;
		}}
	}}
}}
".Trim();

			var member = ParseMemberDeclaration(code)!;
			if (member is PropertyDeclarationSyntax syntax)
			{
				return syntax;
			}

			var up = new CSharpCodeGenerationException("Error generating C# fixed array property.");
			throw up;
		}

		private static void EmitOpaqueDataTypes(
			ImmutableArray<MemberDeclarationSyntax>.Builder builder,
			ImmutableArray<CSharpOpaqueType> opaqueDataTypes)
		{
			foreach (var opaqueDataType in opaqueDataTypes)
			{
				var member = EmitOpaqueStruct(opaqueDataType);
				builder.Add(member);
			}
		}

		private static StructDeclarationSyntax EmitOpaqueStruct(CSharpOpaqueType opaqueType)
		{
			var code = $@"
{opaqueType.CodeLocationComment}
[StructLayout(LayoutKind.Sequential)]
public struct {opaqueType.Name}
{{
}}
";

			var member = ParseMemberDeclaration(code)!;
			if (member is StructDeclarationSyntax syntax)
			{
				return syntax;
			}

			var up = new CSharpCodeGenerationException("Error generating C# opaque struct.");
			throw up;
		}

		private static void EmitTypedefs(
			ImmutableArray<MemberDeclarationSyntax>.Builder builder,
			ImmutableArray<CSharpTypedef> typedefs)
		{
			foreach (var typedef in typedefs)
			{
				var member = EmitTypedef(typedef);
				builder.Add(member);
			}
		}

		private static StructDeclarationSyntax EmitTypedef(CSharpTypedef typedef)
		{
			var code = $@"
{typedef.CodeLocationComment}
[StructLayout(LayoutKind.Explicit, Size = {typedef.UnderlyingType.SizeOf}, Pack = {typedef.UnderlyingType.AlignOf})]
public struct {typedef.Name}
{{
	[FieldOffset(0)] // size = {typedef.UnderlyingType.SizeOf}, padding = 0
    public {typedef.UnderlyingType.Name} Data;

	public static implicit operator {typedef.UnderlyingType.Name}({typedef.Name} data) => data.Data;
	public static implicit operator {typedef.Name}({typedef.UnderlyingType.Name} data) => new() {{Data = data}};
}}
";

			var member = ParseMemberDeclaration(code)!;
			if (member is StructDeclarationSyntax syntax)
			{
				return syntax;
			}

			var up = new CSharpCodeGenerationException("Error generating C# typedef.");
			throw up;
		}

		private static void EmitEnums(
			ImmutableArray<MemberDeclarationSyntax>.Builder builder,
			ImmutableArray<CSharpEnum> enums)
		{
			foreach (var @enum in enums)
			{
				var member = EmitEnum(@enum);
				builder.Add(member);
			}
		}

		private static EnumDeclarationSyntax EmitEnum(CSharpEnum @enum)
		{
			var values = EmitEnumValues(@enum.IntegerType.Name, @enum.Values);
			var valuesString = values.Select(x => x.ToFullString());
			var members = string.Join(",\n", valuesString);

			var code = $@"
{@enum.CodeLocationComment}
public enum {@enum.Name} : {@enum.IntegerType}
    {{
        {members}
    }}
";

			var member = ParseMemberDeclaration(code)!;
			if (member is EnumDeclarationSyntax syntax)
			{
				return syntax;
			}

			var up = new CSharpCodeGenerationException("Error generating C# enum.");
			throw up;
		}

		private static EnumMemberDeclarationSyntax[] EmitEnumValues(
			string enumTypeName, ImmutableArray<CSharpEnumValue> values)
		{
			var builder = ImmutableArray.CreateBuilder<EnumMemberDeclarationSyntax>(values.Length);

			foreach (var value in values)
			{
				var enumEqualsValue = EmitEnumEqualsValue(value.Value, enumTypeName);
				var member = EnumMemberDeclaration(value.Name)
					.WithEqualsValue(enumEqualsValue);

				builder.Add(member);
			}

			return builder.ToArray();
		}

		private static EqualsValueClauseSyntax EmitEnumEqualsValue(long value, string enumTypeName)
		{
			var literalToken = enumTypeName switch
			{
				"int" => Literal((int)value),
				"uint" => Literal((uint)value),
				_ => throw new NotImplementedException($"The enum type is not yet supported: {enumTypeName}.")
			};

			return EqualsValueClause(LiteralExpression(SyntaxKind.NumericLiteralExpression, literalToken));
		}

		private class GeneratorUnexpectedException : Exception
		{
			public GeneratorUnexpectedException(CSharpNode data)
				: base(data.CodeLocationComment)
			{
			}
		}
	}
}
