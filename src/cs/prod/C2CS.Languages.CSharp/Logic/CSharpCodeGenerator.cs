// Copyright (c) Lucas Girouard-Stranks (https://github.com/lithiumtoast). All rights reserved.
// Licensed under the MIT license. See LICENSE file in the Git repository root directory for full license information.

using System;
using System.Collections.Immutable;
using System.Linq;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Formatting;
using static Microsoft.CodeAnalysis.CSharp.SyntaxFactory;

namespace C2CS.CSharp
{
	public static class CSharpCodeGenerator
	{
		public static string GenerateFile(
			string className,
			string libraryName,
			CSharpAbstractSyntaxTree abstractSyntaxTree)
		{
			var builder = ImmutableArray.CreateBuilder<MemberDeclarationSyntax>();

			AddLoaderExterns(builder, abstractSyntaxTree.VariablesExtern);
			AddUnloaderExterns(builder, abstractSyntaxTree.VariablesExtern);

			AddMethodsExterns(builder, abstractSyntaxTree.FunctionExterns);
			AddFunctionPointers(builder, abstractSyntaxTree.FunctionPointers);
			AddStructs(builder, abstractSyntaxTree.Structs);
			AddOpaqueDataTypes(builder, abstractSyntaxTree.OpaqueDataTypes);
			AddTypedefs(builder, abstractSyntaxTree.Typedefs);
			AddEnums(builder, abstractSyntaxTree.Enums);
			AddVariableExterns(builder, abstractSyntaxTree.VariablesExtern);

			var membersToAdd = builder.ToArray();
			var compilationUnit = CreateCompilationUnit(
				className,
				libraryName,
				membersToAdd);
			return compilationUnit.ToFullString();
		}

		private static CompilationUnitSyntax CreateCompilationUnit(
			string className,
			string libraryName,
			MemberDeclarationSyntax[] members)
		{
			var code = $@"
//-------------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by the following tool:
//        https://github.com/lithiumtoast/c2cs
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ReSharper disable All
//-------------------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;

#nullable enable

public static unsafe partial class {className}
{{
    private const string LibraryName = ""{libraryName}"";
	private static IntPtr _libraryHandle;

	public static void LoadApi(string? libraryFilePath = null)
	{{
		UnloadApi();
		if (libraryFilePath == null)
		{{
			var libraryFileNamePrefix = NativeRuntime.LibraryFileNamePrefix;
			var libraryFileNameExtension = NativeRuntime.LibraryFileNameExtension;
			libraryFilePath = $@""{{libraryFileNamePrefix}}{{LibraryName}}{{libraryFileNameExtension}}"";
		}}
		_libraryHandle = NativeRuntime.LibraryLoad(libraryFilePath);
		if (_libraryHandle == IntPtr.Zero)
			throw new Exception($""Failed to load library: {{libraryFilePath}}"");
		LoadExports();
	}}

	public static void UnloadApi()
	{{
		if (_libraryHandle == IntPtr.Zero)
			return;
		UnloadExports();
		NativeRuntime.LibraryUnload(_libraryHandle);
	}}
}}
";

			var syntaxTree = ParseSyntaxTree(code);
			var compilationUnit = syntaxTree.GetCompilationUnitRoot();
			var @class = (ClassDeclarationSyntax)compilationUnit.Members[0];

			var newClass = @class.AddMembers(members);
			var newCompilationUnit = compilationUnit.ReplaceNode(@class, newClass);

			var workspace = new AdhocWorkspace();
			var newCompilationUnitFormatted = (CompilationUnitSyntax)Formatter.Format(newCompilationUnit, workspace);

			return newCompilationUnitFormatted;
		}

		private static void AddLoaderExterns(
			ImmutableArray<MemberDeclarationSyntax>.Builder builder,
			ImmutableArray<CSharpVariable> variablesExtern)
		{
			var statementStrings = variablesExtern.Select(x =>
				@$"_{x.Name} = NativeRuntime.LibraryGetExport(_libraryHandle, ""{x.Name}"");");
			var statements = string.Join('\n', statementStrings);

			var code = $@"
private static void LoadExports()
{{
	{statements}
}}
";

			var member = ParseMemberDeclaration(code)!;
			if (member is MethodDeclarationSyntax syntax)
			{
				builder.Add(syntax);
			}
			else
			{
				var up = new CSharpCodeGenerationException("Error generating C# extern loader method.");
				throw up;
			}
		}

		private static void AddUnloaderExterns(
			ImmutableArray<MemberDeclarationSyntax>.Builder builder,
			ImmutableArray<CSharpVariable> variablesExtern)
		{
			var statementStrings = variablesExtern.Select(x =>
				@$"_{x.Name} = IntPtr.Zero;");
			var statements = string.Join('\n', statementStrings);

			var code = $@"
private static void UnloadExports()
{{
	{statements}
}}
";

			var member = ParseMemberDeclaration(code)!;
			if (member is MethodDeclarationSyntax syntax)
			{
				builder.Add(syntax);
			}
			else
			{
				var up = new CSharpCodeGenerationException("Error generating C# extern unloader method.");
				throw up;
			}
		}

		private static void AddVariableExterns(
			ImmutableArray<MemberDeclarationSyntax>.Builder builder,
			ImmutableArray<CSharpVariable> variablesExtern)
		{
			foreach (var variableExtern in variablesExtern)
			{
				var field = CreateFieldExternAddress(variableExtern);
				builder.Add(field);

				var method = CreateVariableExternMethod(variableExtern);
				builder.Add(method);
			}
		}

		private static FieldDeclarationSyntax CreateFieldExternAddress(CSharpNode @extern)
		{
			var code = $@"
{@extern.CodeLocationComment}
private static IntPtr _{@extern.Name};
".TrimEnd();

			var member = (FieldDeclarationSyntax)ParseMemberDeclaration(code)!;
			return member;
		}

		private static MemberDeclarationSyntax CreateVariableExternMethod(CSharpVariable variable)
		{
			var code = $@"
public static {variable.Type.Name} {variable.Name}
{{
	get
	{{
		if (_{variable.Name} == IntPtr.Zero)
		{{
			return default({variable.Type.Name});
		}}

		var value = NativeRuntime.MemoryRead<{variable.Type.Name}>(_{variable.Name});
		return value;
	}}
}}
";

			var result = ParseMemberDeclaration(code);
			if (result != null)
			{
				return result;
			}

			var up = new GeneratorUnexpectedException(variable);
			throw up;
		}

		private static void AddMethodsExterns(
			ImmutableArray<MemberDeclarationSyntax>.Builder builder,
			ImmutableArray<CSharpFunction> functionExterns)
		{
			foreach (var functionExtern in functionExterns)
			{
				// https://github.com/lithiumtoast/c2cs/issues/15
				var shouldIgnore = false;
				foreach (var cSharpFunctionExternParameter in functionExtern.Parameters)
				{
					if (cSharpFunctionExternParameter.Type.Name == "va_list")
					{
						shouldIgnore = true;
						break;
					}
				}

				if (shouldIgnore)
				{
					continue;
				}

				var member = CreateExternMethod(functionExtern);
				builder.Add(member);
			}
		}

		private static MethodDeclarationSyntax CreateExternMethod(CSharpFunction function)
		{
			var parameterStrings = function.Parameters.Select(
				x => $@"{x.Type.Name} {x.Name}");
			var parameters = string.Join(',', parameterStrings);

			var code = $@"
{function.CodeLocationComment}
[DllImport(LibraryName, EntryPoint = ""{function.Name}"", CallingConvention = CallingConvention.{function.CallingConvention})]
public static extern {function.ReturnType.Name} {function.Name}({parameters});
";

			var member = ParseMemberDeclaration(code)!;
			if (member is MethodDeclarationSyntax syntax)
			{
				return syntax;
			}

			var up = new CSharpCodeGenerationException("Error generating C# extern method.");
			throw up;
		}

		private static void AddFunctionPointers(
			ImmutableArray<MemberDeclarationSyntax>.Builder builder,
			ImmutableArray<CSharpPointerFunction> functionPointers)
		{
			foreach (var functionPointer in functionPointers)
			{
				var member = CreatePointerFunction(functionPointer);
				builder.Add(member);
			}
		}

		public static StructDeclarationSyntax CreatePointerFunction(
			CSharpPointerFunction pointerFunction, bool isNested = false)
		{
			var parameterStrings = pointerFunction.Parameters
				.Select(x => $"{x.Type}").Append($"{pointerFunction.ReturnType.Name}");
			var parameters = string.Join(',', parameterStrings);

			var code = $@"
{pointerFunction.CodeLocationComment}
[StructLayout(LayoutKind.Sequential)]
public struct {pointerFunction.Name}
{{
	public delegate* unmanaged <{parameters}> Pointer;
}}
";

			if (isNested)
			{
				code = code.Trim();
			}

			var member = ParseMemberDeclaration(code)!;
			if (member is StructDeclarationSyntax syntax)
			{
				return syntax;
			}

			var up = new CSharpCodeGenerationException("Error generating C# pointer function.");
			throw up;
		}

		private static void AddStructs(
			ImmutableArray<MemberDeclarationSyntax>.Builder builder,
			ImmutableArray<CSharpStruct> structs)
		{
			foreach (var @struct in structs)
			{
				var member = CreateStruct(@struct);
				builder.Add(member);
			}
		}

		private static StructDeclarationSyntax CreateStruct(CSharpStruct @struct, bool isNested = false)
		{
			var memberSyntaxes = CreateStructMembers(
				@struct.Name, @struct.Fields, @struct.NestedNodes);
			var memberStrings = memberSyntaxes.Select(x => x.ToFullString());
			var members = string.Join("\n\n", memberStrings);

			var code = $@"
{@struct.CodeLocationComment}
[StructLayout(LayoutKind.Explicit, Size = {@struct.Type.SizeOf}, Pack = {@struct.Type.AlignOf})]
public struct {@struct.Name}
{{
	{members}
}}
";

			if (isNested)
			{
				code = code.Trim();
			}

			var member = ParseMemberDeclaration(code)!;
			if (member is StructDeclarationSyntax syntax)
			{
				return syntax;
			}

			var up = new CSharpCodeGenerationException("Error generating C# struct.");
			throw up;
		}

		private static MemberDeclarationSyntax[] CreateStructMembers(
			string structName,
			ImmutableArray<CSharpStructField> fields,
			ImmutableArray<CSharpNode> nestedNodes)
		{
			var builder = ImmutableArray.CreateBuilder<MemberDeclarationSyntax>();

			foreach (var field in fields)
			{
				if (!field.Type.IsArray)
				{
					var fieldMember = CreateStructField(field);
					builder.Add(fieldMember);
				}
				else
				{
					var fieldMember = CreateStructFieldFixedBuffer(field);
					builder.Add(fieldMember);

					var methodMember = CreateStructFieldFixedBufferProperty(
						structName, field);
					builder.Add(methodMember);
				}
			}

			foreach (var nestedNode in nestedNodes)
			{
				var syntax = nestedNode switch
				{
					CSharpStruct nestedStruct => CreateStruct(nestedStruct, true),
					CSharpPointerFunction nestedFunctionPointer => CreatePointerFunction(nestedFunctionPointer, true),
					_ => throw new NotImplementedException()
				};

				builder.Add(syntax);
			}

			var structMembers = builder.ToArray();
			return structMembers;
		}

		private static FieldDeclarationSyntax CreateStructField(CSharpStructField field)
		{
			var code = $@"
[FieldOffset({field.Offset})] // size = {field.Type.SizeOf}, padding = {field.Padding}
public {field.Type.Name} {field.Name};
".Trim();

			var member = ParseMemberDeclaration(code)!;
			if (member is FieldDeclarationSyntax syntax)
			{
				return syntax;
			}

			var up = new CSharpCodeGenerationException("Error generating C# field.");
			throw up;
		}

		private static FieldDeclarationSyntax CreateStructFieldFixedBuffer(
			CSharpStructField field)
		{
			string typeName;

			if (field.IsWrapped)
			{
				typeName = field.Type.AlignOf switch
				{
					1 => "byte",
					2 => "ushort",
					4 => "uint",
					8 => "ulong",
					_ => throw new InvalidOperationException()
				};
			}
			else
			{
				typeName = field.Type.Name;
			}

			var code = $@"
[FieldOffset({field.Offset})] // size = {field.Type.SizeOf}, padding = {field.Padding}
public fixed {typeName} _{field.Name}[{field.Type.SizeOf}/{field.Type.AlignOf}]; // {field.Type.OriginalName}
".Trim();

			var member = (FieldDeclarationSyntax)ParseMemberDeclaration(code)!;
			return member;
		}

		private static PropertyDeclarationSyntax CreateStructFieldFixedBufferProperty(
			string structName,
			CSharpStructField field)
		{
			var fieldTypeName = field.Type.Name;
			if (fieldTypeName == "void*")
			{
				fieldTypeName = "IntPtr";
			}

			var code = $@"
public Span<{fieldTypeName}> {field.Name}
{{
	get
	{{
		fixed ({structName}*@this = &this)
		{{
			var pointer = &@this->_{field.Name}[0];
			var span = new Span<{fieldTypeName}>(pointer, {field.Type.ArraySize});
			return span;
		}}
	}}
}}
".Trim();

			var member = ParseMemberDeclaration(code)!;
			if (member is PropertyDeclarationSyntax syntax)
			{
				return syntax;
			}

			var up = new CSharpCodeGenerationException("Error generating C# fixed array property.");
			throw up;
		}

		private static void AddOpaqueDataTypes(
			ImmutableArray<MemberDeclarationSyntax>.Builder builder,
			ImmutableArray<CSharpOpaqueType> opaqueDataTypes)
		{
			foreach (var opaqueDataType in opaqueDataTypes)
			{
				var member = CreateOpaqueStruct(opaqueDataType);
				builder.Add(member);
			}
		}

		private static StructDeclarationSyntax CreateOpaqueStruct(CSharpOpaqueType opaqueType)
		{
			string code;

			if (opaqueType.SizeOf > 0)
			{
				code = $@"
{opaqueType.CodeLocationComment}
[StructLayout(LayoutKind.Explicit, Size = {opaqueType.SizeOf}, Pack = {opaqueType.AlignOf})]
public struct {opaqueType.Name}
{{
	[FieldOffset(0)]
	public fixed byte Data[{opaqueType.SizeOf}];
}}
";
			}
			else
			{
				code = $@"
{opaqueType.CodeLocationComment}
[StructLayout(LayoutKind.Sequential)]
public struct {opaqueType.Name}
{{
}}
";
			}

			var member = ParseMemberDeclaration(code)!;
			if (member is StructDeclarationSyntax syntax)
			{
				return syntax;
			}

			var up = new CSharpCodeGenerationException("Error generating C# opaque struct.");
			throw up;
		}

		private static void AddTypedefs(
			ImmutableArray<MemberDeclarationSyntax>.Builder builder,
			ImmutableArray<CSharpTypedef> typedefs)
		{
			foreach (var typedef in typedefs)
			{
				var member = CreateTypedef(typedef);
				builder.Add(member);
			}
		}

		private static StructDeclarationSyntax CreateTypedef(CSharpTypedef typedef)
		{
			var code = $@"
{typedef.CodeLocationComment}
[StructLayout(LayoutKind.Explicit, Size = {typedef.UnderlyingType.SizeOf}, Pack = {typedef.UnderlyingType.AlignOf})]
public struct {typedef.Name}
{{
	[FieldOffset(0)] // size = {typedef.UnderlyingType.SizeOf}, padding = 0
    public {typedef.UnderlyingType.Name} Data;

	public static implicit operator {typedef.UnderlyingType.Name}({typedef.Name} data) => data.Data;
	public static implicit operator {typedef.Name}({typedef.UnderlyingType.Name} data) => new() {{Data = data}};
}}
";

			var member = ParseMemberDeclaration(code)!;
			if (member is StructDeclarationSyntax syntax)
			{
				return syntax;
			}

			var up = new CSharpCodeGenerationException("Error generating C# typedef.");
			throw up;
		}

		private static void AddEnums(
			ImmutableArray<MemberDeclarationSyntax>.Builder builder,
			ImmutableArray<CSharpEnum> enums)
		{
			foreach (var @enum in enums)
			{
				var member = CreateEnum(@enum);
				builder.Add(member);
			}
		}

		private static EnumDeclarationSyntax CreateEnum(CSharpEnum @enum)
		{
			var values = CreateEnumValues(@enum.Type.Name, @enum.Values);
			var valuesString = values.Select(x => x.ToFullString());
			var members = string.Join(",\n", valuesString);

			var code = $@"
{@enum.CodeLocationComment}
public enum {@enum.Name} : {@enum.Type}
    {{
        {members}
    }}
";

			var member = ParseMemberDeclaration(code)!;
			if (member is EnumDeclarationSyntax syntax)
			{
				return syntax;
			}

			var up = new CSharpCodeGenerationException("Error generating C# enum.");
			throw up;
		}

		private static EnumMemberDeclarationSyntax[] CreateEnumValues(
			string enumTypeName, ImmutableArray<CSharpEnumValue> values)
		{
			var builder = ImmutableArray.CreateBuilder<EnumMemberDeclarationSyntax>(values.Length);

			foreach (var value in values)
			{
				var enumEqualsValue = CreateEnumEqualsValue(value.Value, enumTypeName);
				var member = EnumMemberDeclaration(value.Name)
					.WithEqualsValue(enumEqualsValue);

				builder.Add(member);
			}

			return builder.ToArray();
		}

		private static EqualsValueClauseSyntax CreateEnumEqualsValue(long value, string enumTypeName)
		{
			var literalToken = enumTypeName switch
			{
				"int" => Literal((int)value),
				"uint" => Literal((uint)value),
				_ => throw new NotImplementedException($"The enum type is not yet supported: {enumTypeName}.")
			};

			return EqualsValueClause(LiteralExpression(SyntaxKind.NumericLiteralExpression, literalToken));
		}

		private class GeneratorUnexpectedException : Exception
		{
			public GeneratorUnexpectedException(CSharpNode data)
				: base(data.CodeLocationComment)
			{
			}
		}
	}
}
