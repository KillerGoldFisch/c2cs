// Copyright (c) Lucas Girouard-Stranks (https://github.com/lithiumtoast). All rights reserved.
// Licensed under the MIT license. See LICENSE file in the Git repository root directory (https://github.com/lithiumtoast/c2cs) for full license information.

using System.Collections.Generic;
using System.Collections.Immutable;
using System.IO;
using ClangSharp.Interop;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using ConstantClang = ClangSharp.EnumConstantDecl;
using EnumClang = ClangSharp.EnumDecl;
using EnumCSharp = Microsoft.CodeAnalysis.CSharp.Syntax.EnumDeclarationSyntax;
using FieldCSharp = Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax;
using FunctionClang = ClangSharp.FunctionDecl;
using MemberCSharp = Microsoft.CodeAnalysis.CSharp.Syntax.MemberDeclarationSyntax;
using MethodCSharp = Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax;
using RecordClang = ClangSharp.RecordDecl;
using StructCSharp = Microsoft.CodeAnalysis.CSharp.Syntax.StructDeclarationSyntax;
using TypeClang = ClangSharp.Type;
using TypedefClang = ClangSharp.TypedefDecl;

namespace C2CS
{
    public class BindgenTranspileCCodeToCSharp
    {
        private CSharpCodeGenerator _cSharpCodeGenerator = null!;
        private ClangLayoutCalculator _layoutCalculator = new();

        private readonly List<FieldCSharp> _constants = new();
        private readonly List<MethodCSharp> _methods = new();
        private readonly List<StructCSharp> _structs = new();
        private readonly List<EnumCSharp> _enums = new();
        private readonly List<MemberCSharp> _functionPointers = new();

        public string GenerateCSharpCode(string libraryName, BindgenClangExtractedCursors extractedCursors)
        {
            _layoutCalculator = new ClangLayoutCalculator();
            _cSharpCodeGenerator = new CSharpCodeGenerator(libraryName, _layoutCalculator);

            foreach (var clangFunction in extractedCursors.Functions)
            {
                TranspileFunction(clangFunction);
            }

            foreach (var clangRecord in extractedCursors.Records)
            {
                TranspileRecord(clangRecord);
            }

            foreach (var clangEnum in extractedCursors.Enums)
            {
                TranspileEnum(clangEnum);
            }

            foreach (var clangOpaqueType in extractedCursors.OpaqueTypes)
            {
                TranspileOpaqueType(clangOpaqueType);
            }

            foreach (var clangExternalType in extractedCursors.ExternalTypes)
            {
                TranspileExternalType(clangExternalType);
            }

            const string comment = @"
//-------------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by the following tool:
//        https://github.com/lithiumtoast/c2cs
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ReSharper disable All
//-------------------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;";

            var commentFormatted = comment.TrimStart() + "\r\n";

            var className = Path.GetFileNameWithoutExtension(libraryName);

            var membersBuilder = ImmutableArray.CreateBuilder<MemberCSharp>();
            membersBuilder.AddRange(_constants);
            membersBuilder.AddRange(_methods);
            membersBuilder.AddRange(_structs);
            membersBuilder.AddRange(_enums);
            membersBuilder.AddRange(_functionPointers);
            var members = membersBuilder.ToImmutableArray();

            var @class = _cSharpCodeGenerator.CreatePInvokeClass(className, members)
                .WithLeadingTrivia(SyntaxFactory.Comment(commentFormatted));

            return @class
                .Format()
                .ToFullString();
        }

        private void TranspileRecord(CXCursor clangRecord)
        {
            var cSharpStruct = _cSharpCodeGenerator.CreateStruct(clangRecord);
            _structs.Add(cSharpStruct);
        }

        private void TranspileFunction(CXCursor clangFunction)
        {
            var cSharpMethod = _cSharpCodeGenerator.CreateExternMethod(clangFunction);
            _methods.Add(cSharpMethod);
        }

        private void TranspileConstant(CXCursor clangConstant)
        {
            var cSharpConstant = _cSharpCodeGenerator.CreateConstant(clangConstant);
            _constants.Add(cSharpConstant);
        }

        private void TranspileEnum(CXCursor clangEnum)
        {
            var name = clangEnum.Spelling.CString;
            if (string.IsNullOrEmpty(name))
            {
                name = clangEnum.Type.Spelling.CString;
            }

            if (string.IsNullOrEmpty(name))
            {
                clangEnum.VisitChildren(TranspileConstant);
            }
            else
            {
                var cSharpEnum = _cSharpCodeGenerator.CreateEnum(clangEnum);
                _enums.Add(cSharpEnum);
            }
        }

        private void TranspileOpaqueType(CXCursor clangTypedef)
        {
            var cSharpStruct = _cSharpCodeGenerator.CreateOpaqueStruct(clangTypedef);
            _structs.Add(cSharpStruct);
        }

        private void TranspileExternalType(CXCursor clangTypedef)
        {
            var cSharpStruct = _cSharpCodeGenerator.CreateExternalStruct(clangTypedef);
            _structs.Add(cSharpStruct);
        }
    }
}
