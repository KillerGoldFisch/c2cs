// Copyright (c) Lucas Girouard-Stranks (https://github.com/lithiumtoast). All rights reserved.
// Licensed under the MIT license. See LICENSE file in the Git repository root directory for full license information.

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.IO;
using System.Linq;
using System.Runtime.InteropServices;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using static Microsoft.CodeAnalysis.CSharp.SyntaxFactory;

namespace C2CS.CSharp
{
	public static class CSharpCodeGenerator
	{
		public static string GenerateFile(
			string className,
			string libraryName,
			CSharpAbstractSyntaxTree abstractSyntaxTree)
		{
			var members = new List<MemberDeclarationSyntax>();

			foreach (var functionExtern in abstractSyntaxTree.FunctionExterns)
			{
				// https://github.com/lithiumtoast/c2cs/issues/15
				var shouldIgnore = false;
				foreach (var parameter in functionExtern.Parameters)
				{
					if (parameter.Type.Name == "__va_list_tag")
					{
						shouldIgnore = true;
						break;
					}
				}

				if (shouldIgnore)
				{
					continue;
				}

				var member = CreateExternMethod(functionExtern);
				members.Add(member);
			}

			foreach (var functionPointer in abstractSyntaxTree.FunctionPointers)
			{
				var member = CreateFunctionPointer(functionPointer);
				members.Add(member);
			}

			foreach (var @struct in abstractSyntaxTree.Structs)
			{
				var member = CreateStruct(@struct);
				members.Add(member);
			}

			foreach (var opaqueDataType in abstractSyntaxTree.OpaqueDataTypes)
			{
				var member = CreateOpaqueStruct(opaqueDataType);
				members.Add(member);
			}

			foreach (var @enum in abstractSyntaxTree.Enums)
			{
				var member = CreateEnum(@enum);
				members.Add(member);
			}

			var @class = CreatePInvokeClass(className, libraryName, members.ToImmutableArray());
			return @class.ToFullString();
		}

		private static ClassDeclarationSyntax CreatePInvokeClass(
			string className, string libraryName, ImmutableArray<MemberDeclarationSyntax> members)
		{
			var newMembers = new List<MemberDeclarationSyntax>();

			var libraryNameField = FieldDeclaration(
					VariableDeclaration(PredefinedType(Token(SyntaxKind.StringKeyword)))
						.WithVariables(SingletonSeparatedList(VariableDeclarator(Identifier("LibraryName"))
							.WithInitializer(
								EqualsValueClause(LiteralExpression(
									SyntaxKind.StringLiteralExpression,
									Literal(libraryName)))))))
				.WithModifiers(
					TokenList(Token(SyntaxKind.PrivateKeyword), Token(SyntaxKind.ConstKeyword)));

			newMembers.Add(libraryNameField);
			newMembers.AddRange(members);

			const string comment = @"
//-------------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by the following tool:
//        https://github.com/lithiumtoast/c2cs
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ReSharper disable All
//-------------------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;";

			var commentFormatted = comment.TrimStart() + "\r\n";

			var result = ClassDeclaration(className)
				.AddModifiers(
					Token(SyntaxKind.PublicKeyword),
					Token(SyntaxKind.StaticKeyword),
					Token(SyntaxKind.UnsafeKeyword),
					Token(SyntaxKind.PartialKeyword))
				.WithMembers(List(
					newMembers))
				.WithLeadingTrivia(Comment(commentFormatted))
				.Format();

			return result;
		}

		private static MethodDeclarationSyntax CreateExternMethod(CSharpFunctionExtern cSharpFunctionExtern)
		{
			var functionName = cSharpFunctionExtern.Name;
			var functionReturnTypeName = cSharpFunctionExtern.ReturnType.Name;
			var functionReturnType = ParseTypeName(functionReturnTypeName);
			var functionCallingConvention = CallingConvention(cSharpFunctionExtern.CallingConvention);
			var functionParameters = cSharpFunctionExtern.Parameters;

			var methodParameters = CreateExternMethodParameters(functionParameters);

			var method = MethodDeclaration(functionReturnType, functionName)
				.WithDllImportAttribute(functionName, functionCallingConvention)
				.WithModifiers(TokenList(
					Token(SyntaxKind.PublicKeyword),
					Token(SyntaxKind.StaticKeyword),
					Token(SyntaxKind.ExternKeyword)))
				.WithSemicolonToken(Token(SyntaxKind.SemicolonToken))
				.AddParameterListParameters(methodParameters.ToArray())
				.WithLeadingTrivia(Comment(cSharpFunctionExtern.CodeLocationComment));

			return method;
		}

		private static CallingConvention CallingConvention(CSharpFunctionExternCallingConvention callingConvention)
		{
			return callingConvention switch
			{
				CSharpFunctionExternCallingConvention.Unknown => System.Runtime.InteropServices.CallingConvention.Winapi,
				CSharpFunctionExternCallingConvention.C => System.Runtime.InteropServices.CallingConvention.Cdecl,
				_ => throw new ArgumentOutOfRangeException(nameof(callingConvention), callingConvention, null)
			};
		}

		private static ImmutableArray<ParameterSyntax> CreateExternMethodParameters(
			ImmutableArray<CSharpFunctionExternParameter> functionParameters)
		{
			var cSharpMethodParameters = ImmutableArray.CreateBuilder<ParameterSyntax>();

			foreach (var functionParameter in functionParameters)
			{
				var cSharpMethodParameter = CreateExternMethodParameter(functionParameter);
				cSharpMethodParameters.Add(cSharpMethodParameter);
			}

			return cSharpMethodParameters.ToImmutable();
		}

		private static ParameterSyntax CreateExternMethodParameter(CSharpFunctionExternParameter functionParameter)
		{
			var parameterIsReadOnly = functionParameter.IsReadOnly;

			var parameterIdentifier = Identifier(functionParameter.Name);
			var parameterType = ParseTypeName(functionParameter.Type.Name);
			var parameter = Parameter(parameterIdentifier)
				.WithType(parameterType);

			if (parameterIsReadOnly)
			{
				parameter = parameter.WithAttribute("In");
			}

			if (parameterType is PointerTypeSyntax)
			{
				parameter = parameter.WithTrailingTrivia(Space);
			}

			return parameter;
		}

		public static MemberDeclarationSyntax CreateFunctionPointer(CSharpFunctionPointer cSharpFunctionPointer)
		{
			var structName = cSharpFunctionPointer.Name;
			var pointerSize = cSharpFunctionPointer.PointerSize;

			List<SyntaxNodeOrToken> functionPointerParameterList = new();

			foreach (var functionPointerParameter in cSharpFunctionPointer.Parameters)
			{
				var parameterType = ParseTypeName(functionPointerParameter.Type.Name);
				var parameter = FunctionPointerParameter(parameterType);
				functionPointerParameterList.Add(parameter);
				functionPointerParameterList.Add(Token(SyntaxKind.CommaToken));
			}

			var returnType = ParseTypeName(cSharpFunctionPointer.ReturnType.Name);
			functionPointerParameterList.Add(FunctionPointerParameter(returnType));

			var functionPointer = FunctionPointerType()
				.WithCallingConvention(
					FunctionPointerCallingConvention(
						Token(SyntaxKind.UnmanagedKeyword)))
				.WithParameterList(
					FunctionPointerParameterList(
						SeparatedList<FunctionPointerParameterSyntax>(functionPointerParameterList.ToArray())));

			var fieldIdentifier = Identifier("Pointer");
			var fieldType = functionPointer;
			var fieldVariable = VariableDeclarator(fieldIdentifier);
			var fieldVariableDeclaration = VariableDeclaration(fieldType)
				.WithVariables(SingletonSeparatedList(fieldVariable));
			var field = FieldDeclaration(fieldVariableDeclaration)
				.WithModifiers(TokenList(Token(SyntaxKind.PublicKeyword)))
				.WithAttributeFieldOffset(0, pointerSize, 0);

			var @struct = StructDeclaration(structName)
				.WithModifiers(TokenList(Token(SyntaxKind.PublicKeyword)))
				.WithAttributeStructLayout(LayoutKind.Explicit, pointerSize, pointerSize)
				.WithMembers(new SyntaxList<MemberDeclarationSyntax>(field))
				.WithLeadingTrivia(Comment(cSharpFunctionPointer.CodeLocationComment));

			return @struct;
		}

		private static EnumDeclarationSyntax CreateEnum(CSharpEnum cSharpEnum)
		{
			var values = CreateEnumValues(cSharpEnum.Type.Name, cSharpEnum.Values);

			var @enum = EnumDeclaration(cSharpEnum.Name)
				.AddModifiers(Token(SyntaxKind.PublicKeyword))
				.AddBaseListTypes(SimpleBaseType(ParseTypeName(cSharpEnum.Type.Name)))
				.WithLeadingTrivia(Comment(cSharpEnum.CodeLocationComment))
				.AddMembers(values);

			return @enum;
		}

		private static EnumMemberDeclarationSyntax[] CreateEnumValues(
			string enumTypeName, ImmutableArray<CSharpEnumValue> values)
		{
			var builder = ImmutableArray.CreateBuilder<EnumMemberDeclarationSyntax>(values.Length);

			foreach (var value in values)
			{
				var enumEqualsValue = CreateEnumEqualsValue(value.Value, enumTypeName);
				var member = EnumMemberDeclaration(value.Name)
					.WithEqualsValue(enumEqualsValue);

				builder.Add(member);
			}

			return builder.ToArray();
		}

		private static EqualsValueClauseSyntax CreateEnumEqualsValue(long value, string enumTypeName)
		{
			var literalToken = enumTypeName switch
			{
				"int" => Literal((int)value),
				"uint" => Literal((uint)value),
				_ => throw new NotImplementedException($"The enum type is not yet supported: {enumTypeName}.")
			};

			return EqualsValueClause(LiteralExpression(SyntaxKind.NumericLiteralExpression, literalToken));
		}

		private static StructDeclarationSyntax CreateOpaqueStruct(CSharpOpaqueDataType cSharpOpaqueDataType)
		{
			var structName = cSharpOpaqueDataType.Name;
			var codeLocationComment = cSharpOpaqueDataType.CodeLocationComment;

			var @struct = StructDeclaration(structName)
				.WithModifiers(TokenList(Token(SyntaxKind.PublicKeyword)))
				.WithAttributeStructLayout(LayoutKind.Sequential)
				.WithLeadingTrivia(Comment(codeLocationComment));

			return @struct;
		}

		private static StructDeclarationSyntax CreateStruct(CSharpStruct cSharpStruct)
		{
			var structName = cSharpStruct.Name;
			var structSize = cSharpStruct.Type.SizeOf;
			var structAlignment = cSharpStruct.Type.AlignOf;
			var codeLocationComment = cSharpStruct.CodeLocationComment;

			var structMembers = CreateStructMembers(
				structName, cSharpStruct.Fields, cSharpStruct.NestedStructs);

			var @struct = StructDeclaration(structName)
				.WithModifiers(TokenList(Token(SyntaxKind.PublicKeyword)))
				.WithAttributeStructLayout(LayoutKind.Explicit, structSize, structAlignment)
				.WithLeadingTrivia(Comment(codeLocationComment))
				.AddMembers(structMembers);

			return @struct;
		}

		private static MemberDeclarationSyntax[] CreateStructMembers(
			string structName,
			ImmutableArray<CSharpStructField> fields,
			ImmutableArray<CSharpStruct> nestedStructs)
		{
			var builder = ImmutableArray.CreateBuilder<MemberDeclarationSyntax>();

			foreach (var cSharpField in fields)
			{
				var field = CreateStructField(cSharpField);
				builder.Add(field);

				var isWrapped = cSharpField.IsWrapped;
				if (isWrapped)
				{
					var wrappedMethod = CreateStructFieldFixedBufferWrapperMethod(structName, cSharpField);
					builder.Add(wrappedMethod);
				}
			}

			foreach (var cSharpStructNested in nestedStructs)
			{
				var structNested = CreateStruct(cSharpStructNested);
				builder.Add(structNested);
			}

			var structMembers = builder.ToArray();
			return structMembers;
		}

		private static FieldDeclarationSyntax CreateStructField(CSharpStructField cSharpStructField)
		{
			var isArray = cSharpStructField.Type.IsArray;
			var result = isArray ?
				CreateStructFieldFixedBuffer(cSharpStructField) :
				CreateStructFieldNormal(cSharpStructField);
			return result;
		}

		private static FieldDeclarationSyntax CreateStructFieldNormal(CSharpStructField cSharpStructField)
		{
			var fieldName = cSharpStructField.Name;
			var fieldTypeName = cSharpStructField.Type.Name;
			var fieldOffset = cSharpStructField.Offset;
			var fieldSizeOf = cSharpStructField.Type.SizeOf;
			var fieldPadding = cSharpStructField.Padding;

			var fieldNameIdentifier = Identifier(fieldName);
			var fieldType = ParseTypeName(fieldTypeName);
			var fieldVariable = VariableDeclarator(fieldNameIdentifier);
			var fieldVariableDeclaration = VariableDeclaration(fieldType)
				.WithVariables(SingletonSeparatedList(fieldVariable));
			var field = FieldDeclaration(fieldVariableDeclaration)
				.WithModifiers(TokenList(Token(SyntaxKind.PublicKeyword)))
				.WithAttributeFieldOffset(fieldOffset, fieldSizeOf, fieldPadding);

			return field;
		}

		private static FieldDeclarationSyntax CreateStructFieldFixedBuffer(CSharpStructField cSharpStructField)
		{
			var fieldName = cSharpStructField.Name;
			var fieldOriginalName = cSharpStructField.OriginalName;
			var fieldTypeName = cSharpStructField.Type.Name;
			var fieldSizeOf = cSharpStructField.Type.SizeOf;
			var fieldAlignOf = cSharpStructField.Type.AlignOf;
			var fieldPadding = cSharpStructField.Padding;
			var fieldIsWrapped = cSharpStructField.IsWrapped;
			var fieldOffset = cSharpStructField.Offset;

			var fieldType = ParseTypeName(fieldTypeName);
			VariableDeclaratorSyntax fieldVariable;

			if (fieldIsWrapped)
			{
				var typeSyntaxKind = fieldAlignOf switch
				{
					1 => SyntaxKind.ByteKeyword,
					2 => SyntaxKind.UShortKeyword,
					4 => SyntaxKind.UIntKeyword,
					8 => SyntaxKind.ULongKeyword,
					_ => throw new InvalidOperationException()
				};

				fieldType = PredefinedType(Token(typeSyntaxKind));
				fieldVariable = VariableDeclarator(Identifier($"_{fieldOriginalName}"))
					.WithArgumentList(BracketedArgumentList(SingletonSeparatedList(
						Argument(
							BinaryExpression(
								SyntaxKind.DivideExpression,
								LiteralExpression(
									SyntaxKind.NumericLiteralExpression,
									Literal(fieldSizeOf)),
								LiteralExpression(
									SyntaxKind.NumericLiteralExpression,
									Literal(fieldAlignOf)))))));
			}
			else
			{
				var arraySize = fieldSizeOf / fieldAlignOf;
				fieldVariable = VariableDeclarator(Identifier(fieldName))
					.WithArgumentList(
						BracketedArgumentList(
							SingletonSeparatedList(
								Argument(
									LiteralExpression(
										SyntaxKind.NumericLiteralExpression,
										Literal(arraySize))))));
			}

			var field = FieldDeclaration(VariableDeclaration(fieldType)
				.WithVariables(SingletonSeparatedList(fieldVariable)))
				.WithModifiers(TokenList(
					Token(SyntaxKind.PublicKeyword),
					Token(SyntaxKind.FixedKeyword)))
				.WithAttributeFieldOffset(fieldOffset, fieldSizeOf, fieldPadding)
				.WithSemicolonToken(Token(TriviaList(), SyntaxKind.SemicolonToken, TriviaList(
					Comment($"// original type is `{cSharpStructField.Type.OriginalName}`"))));

			return field;
		}

		private static MethodDeclarationSyntax CreateStructFieldFixedBufferWrapperMethod(
			string structName,
			CSharpStructField cSharpStructField)
		{
			var cSharpMethodName = cSharpStructField.Name;
			var cSharpFieldName = $"_{cSharpStructField.OriginalName}";
			var cSharpStructTypeName = ParseTypeName(structName);
			var cSharpFieldType = ParseTypeName(cSharpStructField.Type.Name);

			var body = Block(SingletonList<StatementSyntax>(FixedStatement(
				VariableDeclaration(PointerType(cSharpStructTypeName))
					.WithVariables(SingletonSeparatedList(VariableDeclarator(Identifier("@this"))
						.WithInitializer(EqualsValueClause(
							PrefixUnaryExpression(SyntaxKind.AddressOfExpression, ThisExpression()))))),
				Block(
					LocalDeclarationStatement(VariableDeclaration(IdentifierName("var"))
						.WithVariables(SingletonSeparatedList(VariableDeclarator(Identifier("pointer"))
							.WithInitializer(EqualsValueClause(CastExpression(
								PointerType(cSharpFieldType),
								PrefixUnaryExpression(SyntaxKind.AddressOfExpression, ElementAccessExpression(
										MemberAccessExpression(
											SyntaxKind.PointerMemberAccessExpression,
											IdentifierName("@this"),
											IdentifierName(cSharpFieldName)))
									.WithArgumentList(BracketedArgumentList(SingletonSeparatedList(
										Argument(LiteralExpression(
											SyntaxKind.NumericLiteralExpression,
											Literal(0))))))))))))),
					LocalDeclarationStatement(VariableDeclaration(IdentifierName("var"))
						.WithVariables(SingletonSeparatedList(VariableDeclarator(
								Identifier("pointerOffset"))
							.WithInitializer(EqualsValueClause(
								IdentifierName("index")))))),
					ReturnStatement(RefExpression(PrefixUnaryExpression(
						SyntaxKind.PointerIndirectionExpression,
						ParenthesizedExpression(BinaryExpression(
							SyntaxKind.AddExpression,
							IdentifierName("pointer"),
							IdentifierName("pointerOffset"))))))))));

			return MethodDeclaration(RefType(cSharpFieldType), cSharpMethodName)
				.WithModifiers(TokenList(
					Token(SyntaxKind.PublicKeyword)))
				.WithParameterList(ParameterList(SingletonSeparatedList(
					Parameter(Identifier("index"))
						.WithType(PredefinedType(Token(SyntaxKind.IntKeyword)))
						.WithDefault(EqualsValueClause(LiteralExpression(
							SyntaxKind.NumericLiteralExpression,
							Literal(0)))))))
				.WithBody(body);
		}
	}
}
