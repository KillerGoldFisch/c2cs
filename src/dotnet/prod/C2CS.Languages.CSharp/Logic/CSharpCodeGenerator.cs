// Copyright (c) Lucas Girouard-Stranks (https://github.com/lithiumtoast). All rights reserved.
// Licensed under the MIT license. See LICENSE file in the Git repository root directory for full license information.

using System;
using System.Collections.Immutable;
using System.Linq;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Formatting;
using static Microsoft.CodeAnalysis.CSharp.SyntaxFactory;

namespace C2CS.CSharp
{
	public static class CSharpCodeGenerator
	{
		public static string GenerateFile(
			string className,
			string libraryName,
			CSharpAbstractSyntaxTree abstractSyntaxTree)
		{
			var builder = ImmutableArray.CreateBuilder<MemberDeclarationSyntax>();

			AddLoaderExterns(builder, abstractSyntaxTree.VariablesExtern);
			AddUnloaderExterns(builder, abstractSyntaxTree.VariablesExtern);

			AddMethodsExterns(builder, abstractSyntaxTree.FunctionExterns);
			AddFunctionPointers(builder, abstractSyntaxTree.FunctionPointers);
			AddStructs(builder, abstractSyntaxTree.Structs);
			AddOpaqueDataTypes(builder, abstractSyntaxTree.OpaqueDataTypes);
			AddEnums(builder, abstractSyntaxTree.Enums);
			AddVariableExterns(builder, abstractSyntaxTree.VariablesExtern);

			var membersToAdd = builder.ToArray();
			var compilationUnit = CreateCompilationUnit(
				className,
				libraryName,
				membersToAdd);
			return compilationUnit.ToFullString();
		}

		private static CompilationUnitSyntax CreateCompilationUnit(
			string className,
			string libraryName,
			MemberDeclarationSyntax[] members)
		{
			var code = $@"
//-------------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by the following tool:
//        https://github.com/lithiumtoast/c2cs
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ReSharper disable All
//-------------------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;

#nullable enable

public static unsafe partial class {className}
{{
    private const string LibraryName = ""{libraryName}"";
	private static IntPtr _libraryHandle;

	public static void LoadApi(string? libraryFilePath = null)
	{{
		UnloadApi();
		if (libraryFilePath == null)
		{{
			var libraryFileNamePrefix = NativeTools.LibraryFileNamePrefix;
			var libraryFileNameExtension = NativeTools.LibraryFileNameExtension;
			libraryFilePath = $@""{{libraryFileNamePrefix}}{{LibraryName}}{{libraryFileNameExtension}}"";
		}}
		_libraryHandle = NativeTools.LibraryLoad(libraryFilePath);
		if (_libraryHandle == IntPtr.Zero)
			throw new Exception($""Failed to load library: {{libraryFilePath}}"");
		LoadExports();
	}}

	public static void UnloadApi()
	{{
		if (_libraryHandle == IntPtr.Zero)
			return;
		UnloadExports();
		NativeTools.LibraryUnload(_libraryHandle);
	}}
}}
";

			var syntaxTree = ParseSyntaxTree(code);
			var compilationUnit = syntaxTree.GetCompilationUnitRoot();
			var @class = (ClassDeclarationSyntax)compilationUnit.Members[0];

			var newClass = @class.AddMembers(members);
			var newCompilationUnit = compilationUnit.ReplaceNode(@class, newClass);

			var workspace = new AdhocWorkspace();
			var newCompilationUnitFormatted = (CompilationUnitSyntax)Formatter.Format(newCompilationUnit, workspace);

			return newCompilationUnitFormatted;
		}

		private static void AddLoaderExterns(
			ImmutableArray<MemberDeclarationSyntax>.Builder builder,
			ImmutableArray<CSharpVariable> variablesExtern)
		{
			var statementStrings = variablesExtern.Select(x =>
				@$"_{x.Name} = NativeTools.LibraryGetExport(_libraryHandle, ""{x.Name}"");");
			var statements = string.Join('\n', statementStrings);

			var code = $@"
private static void LoadExports()
{{
	{statements}
}}
";

			var method = (MethodDeclarationSyntax)ParseMemberDeclaration(code)!;
			builder.Add(method);
		}

		private static void AddUnloaderExterns(
			ImmutableArray<MemberDeclarationSyntax>.Builder builder,
			ImmutableArray<CSharpVariable> variablesExtern)
		{
			var statementStrings = variablesExtern.Select(x =>
				@$"_{x.Name} = IntPtr.Zero;");
			var statements = string.Join('\n', statementStrings);

			var code = $@"
private static void UnloadExports()
{{
	{statements}
}}
";

			var method = (MethodDeclarationSyntax)ParseMemberDeclaration(code)!;
			builder.Add(method);
		}

		private static void AddVariableExterns(
			ImmutableArray<MemberDeclarationSyntax>.Builder builder,
			ImmutableArray<CSharpVariable> variablesExtern)
		{
			foreach (var variableExtern in variablesExtern)
			{
				var field = CreateFieldExternAddress(variableExtern);
				builder.Add(field);

				var method = CreateVariableExternMethod(variableExtern);
				builder.Add(method);
			}
		}

		private static FieldDeclarationSyntax CreateFieldExternAddress(CSharpCommon @extern)
		{
			var code = $@"
{@extern.CodeLocationComment}
private static IntPtr _{@extern.Name};
".TrimEnd();

			var member = (FieldDeclarationSyntax)ParseMemberDeclaration(code)!;
			return member;
		}

		private static MemberDeclarationSyntax CreateVariableExternMethod(CSharpVariable variable)
		{
			var code = $@"
public static {variable.Type.Name} {variable.Name}
{{
	get
	{{
		if (_{variable.Name} == IntPtr.Zero)
		{{
			return default({variable.Type.Name});
		}}

		var value = NativeTools.MemoryRead<{variable.Type.Name}>(_{variable.Name});
		return value;
	}}
}}
";

			var result = ParseMemberDeclaration(code);
			if (result != null)
			{
				return result;
			}

			var up = new GeneratorUnexpectedException(variable);
			throw up;
		}

		private static void AddMethodsExterns(
			ImmutableArray<MemberDeclarationSyntax>.Builder builder,
			ImmutableArray<CSharpFunctionExtern> functionExterns)
		{
			foreach (var functionExtern in functionExterns)
			{
				// https://github.com/lithiumtoast/c2cs/issues/15
				var shouldIgnore = false;
				foreach (var cSharpFunctionExternParameter in functionExtern.Parameters)
				{
					if (cSharpFunctionExternParameter.Type.Name == "__va_list_tag")
					{
						shouldIgnore = true;
						break;
					}
				}

				if (shouldIgnore)
				{
					continue;
				}

				var member = CreateExternMethod(functionExtern);
				builder.Add(member);
			}
		}

		private static MethodDeclarationSyntax CreateExternMethod(CSharpFunctionExtern functionExtern)
		{
			var parameterStrings = functionExtern.Parameters
				.Select(x => $@"{x.Type} {x.Name}");
			var parameters = string.Join(',', parameterStrings);

			var code = $@"
{functionExtern.CodeLocationComment}
[DllImport(LibraryName, EntryPoint = ""{functionExtern.Name}"", CallingConvention = CallingConvention.{functionExtern.CallingConvention})]
public static extern {functionExtern.ReturnType.Name} {functionExtern.Name}({parameters});
";
			var method = (MethodDeclarationSyntax)ParseMemberDeclaration(code)!;
			return method;
		}

		private static void AddFunctionPointers(
			ImmutableArray<MemberDeclarationSyntax>.Builder builder,
			ImmutableArray<CSharpFunctionPointer> functionPointers)
		{
			foreach (var functionPointer in functionPointers)
			{
				var member = CreateFunctionPointer(functionPointer);
				builder.Add(member);
			}
		}

		public static StructDeclarationSyntax CreateFunctionPointer(CSharpFunctionPointer functionPointer)
		{
			var parameterStrings = functionPointer.Parameters
				.Select(x => $"{x.Type}").Append($"{functionPointer.ReturnType.Name}");
			var parameters = string.Join(',', parameterStrings);

			var code = $@"
{functionPointer.CodeLocationComment}
[StructLayout(LayoutKind.Explicit, Size = {functionPointer.PointerSize}, Pack = {functionPointer.PointerSize})]
public struct {functionPointer.Name}
{{
	[FieldOffset(0)] // size = {functionPointer.PointerSize}, padding = 0
	public delegate* unmanaged <{parameters}> Pointer;
}}
";

			var member = (StructDeclarationSyntax)ParseMemberDeclaration(code)!;
			return member;
		}

		private static void AddStructs(
			ImmutableArray<MemberDeclarationSyntax>.Builder builder,
			ImmutableArray<CSharpStruct> structs)
		{
			foreach (var @struct in structs)
			{
				var member = CreateStruct(@struct);
				builder.Add(member);
			}
		}

		private static StructDeclarationSyntax CreateStruct(CSharpStruct @struct)
		{
			var memberSyntaxes = CreateStructMembers(
				@struct.Name, @struct.Fields, @struct.NestedStructs);
			var memberStrings = memberSyntaxes.Select(x => x.ToFullString());
			var members = string.Join("\n\n", memberStrings);

			var code = $@"
{@struct.CodeLocationComment}
[StructLayout(LayoutKind.Explicit, Size = {@struct.Type.SizeOf}, Pack = {@struct.Type.AlignOf})]
public struct {@struct.Name}
{{
	{members}
}}
";

			var member = (StructDeclarationSyntax)ParseMemberDeclaration(code)!;
			return member;
		}

		private static MemberDeclarationSyntax[] CreateStructMembers(
			string structName,
			ImmutableArray<CSharpStructField> fields,
			ImmutableArray<CSharpStruct> nestedStructs)
		{
			var builder = ImmutableArray.CreateBuilder<MemberDeclarationSyntax>();

			foreach (var field in fields)
			{
				var member = CreateStructField(field);
				builder.Add(member);

				var isWrapped = field.IsWrapped;
				if (isWrapped)
				{
					var wrappedMethod = CreateStructFieldFixedBufferWrapperMethod(structName, field);
					builder.Add(wrappedMethod);
				}
			}

			foreach (var nestedStruct in nestedStructs)
			{
				var structNested = CreateStruct(nestedStruct);
				builder.Add(structNested);
			}

			var structMembers = builder.ToArray();
			return structMembers;
		}

		private static FieldDeclarationSyntax CreateStructField(CSharpStructField cSharpStructField)
		{
			var isArray = cSharpStructField.Type.IsArray;
			var result = isArray ?
				CreateStructFieldFixedBuffer(cSharpStructField) :
				CreateStructFieldNormal(cSharpStructField);
			return result;
		}

		private static FieldDeclarationSyntax CreateStructFieldNormal(CSharpStructField field)
		{
			var code = $@"
[FieldOffset({field.Offset})] // size = {field.Type.SizeOf}, padding = {field.Padding}
public {field.Type.Name} {field.Name};
".Trim();

			var member = (FieldDeclarationSyntax)ParseMemberDeclaration(code)!;
			return member;
		}

		private static FieldDeclarationSyntax CreateStructFieldFixedBuffer(CSharpStructField field)
		{
			string typeName;

			if (field.IsWrapped)
			{
				typeName = field.Type.AlignOf switch
				{
					1 => "byte",
					2 => "ushort",
					4 => "uint",
					8 => "ulong",
					_ => throw new InvalidOperationException()
				};
			}
			else
			{
				typeName = field.Type.Name;
			}

			var code = $@"
[FieldOffset({field.Offset})] // size = {field.Type.SizeOf}, padding = {field.Padding}
public fixed {typeName} _{field.OriginalName}[{field.Type.SizeOf}/{field.Type.AlignOf}]; // original type is `{field.Type.OriginalName}`
".Trim();

			var member = (FieldDeclarationSyntax)ParseMemberDeclaration(code)!;
			return member;
		}

		private static MethodDeclarationSyntax CreateStructFieldFixedBufferWrapperMethod(
			string structName,
			CSharpStructField field)
		{
			var code = @$"
public ref {field.Type.Name} {field.Name}(int index = 0)
{{
	fixed ({structName}* @this = &this)
	{{
		var pointer = ({field.Type.Name}*)&@this->_{field.OriginalName}[0];
		var pointerOffset = index;
		return ref *(pointer + pointerOffset);
	}}
}}
".Trim();

			var member = (MethodDeclarationSyntax)ParseMemberDeclaration(code)!;
			return member;
		}

		private static void AddOpaqueDataTypes(
			ImmutableArray<MemberDeclarationSyntax>.Builder builder,
			ImmutableArray<CSharpOpaqueDataType> opaqueDataTypes)
		{
			foreach (var opaqueDataType in opaqueDataTypes)
			{
				var member = CreateOpaqueStruct(opaqueDataType);
				builder.Add(member);
			}
		}

		private static StructDeclarationSyntax CreateOpaqueStruct(CSharpOpaqueDataType opaqueDataType)
		{
			var code = $@"
{opaqueDataType.CodeLocationComment}
[StructLayout(LayoutKind.Sequential)]
public struct {opaqueDataType.Name}
{{
}}
";
			var @struct = (StructDeclarationSyntax)ParseMemberDeclaration(code)!;
			return @struct;
		}

		private static void AddEnums(
			ImmutableArray<MemberDeclarationSyntax>.Builder builder,
			ImmutableArray<CSharpEnum> enums)
		{
			foreach (var @enum in enums)
			{
				var member = CreateEnum(@enum);
				builder.Add(member);
			}
		}

		private static EnumDeclarationSyntax CreateEnum(CSharpEnum @enum)
		{
			var values = CreateEnumValues(@enum.Type.Name, @enum.Values);
			var valuesString = values.Select(x => x.ToFullString());
			var members = string.Join(",\n", valuesString);

			var code = $@"
{@enum.CodeLocationComment}
public enum {@enum.Name} : {@enum.Type}
    {{
        {members}
    }}
";

			var member = (EnumDeclarationSyntax)ParseMemberDeclaration(code)!;
			return member;
		}

		private static EnumMemberDeclarationSyntax[] CreateEnumValues(
			string enumTypeName, ImmutableArray<CSharpEnumValue> values)
		{
			var builder = ImmutableArray.CreateBuilder<EnumMemberDeclarationSyntax>(values.Length);

			foreach (var value in values)
			{
				var enumEqualsValue = CreateEnumEqualsValue(value.Value, enumTypeName);
				var member = EnumMemberDeclaration(value.Name)
					.WithEqualsValue(enumEqualsValue);

				builder.Add(member);
			}

			return builder.ToArray();
		}

		private static EqualsValueClauseSyntax CreateEnumEqualsValue(long value, string enumTypeName)
		{
			var literalToken = enumTypeName switch
			{
				"int" => Literal((int)value),
				"uint" => Literal((uint)value),
				_ => throw new NotImplementedException($"The enum type is not yet supported: {enumTypeName}.")
			};

			return EqualsValueClause(LiteralExpression(SyntaxKind.NumericLiteralExpression, literalToken));
		}

		private static MemberDeclarationSyntax CreateExternAddressField(CSharpVariable variable)
		{
			var code = $@"
private static IntPtr _{variable.Name};
".Trim();

			var result = ParseMemberDeclaration(code);
			if (result != null)
			{
				return result;
			}

			var up = new GeneratorUnexpectedException(variable);
			throw up;
		}

		private class GeneratorUnexpectedException : Exception
		{
			public GeneratorUnexpectedException(CSharpCommon data)
				: base(data.CodeLocationComment)
			{
			}
		}
	}
}
