// Copyright (c) Lucas Girouard-Stranks (https://github.com/lithiumtoast). All rights reserved.
// Licensed under the MIT license. See LICENSE file in the Git repository root directory (https://github.com/lithiumtoast/c2cs) for full license information.

using System.Collections.Generic;
using System.Collections.Immutable;
using System.IO;
using ClangSharp.Interop;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using ConstantClang = ClangSharp.EnumConstantDecl;
using EnumClang = ClangSharp.EnumDecl;
using EnumCSharp = Microsoft.CodeAnalysis.CSharp.Syntax.EnumDeclarationSyntax;
using FieldCSharp = Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax;
using FunctionClang = ClangSharp.FunctionDecl;
using MemberCSharp = Microsoft.CodeAnalysis.CSharp.Syntax.MemberDeclarationSyntax;
using MethodCSharp = Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax;
using RecordClang = ClangSharp.RecordDecl;
using StructCSharp = Microsoft.CodeAnalysis.CSharp.Syntax.StructDeclarationSyntax;
using TypeClang = ClangSharp.Type;
using TypedefClang = ClangSharp.TypedefDecl;

namespace C2CS
{
	public class GeneratePlatformInvokeCodeUseCase
	{
		private readonly CSharpCodeGenerator _cSharpCodeGenerator;
		private readonly ClangCodeExplorer _codeExplorer = new();
		private readonly ClangLayoutCalculator _layoutCalculator = new();

		private readonly List<EnumCSharp> _enums = new();
		private readonly List<FieldCSharp> _fields = new();
		private readonly List<MemberCSharp> _functionPointers = new();
		private readonly List<MethodCSharp> _methods = new();
		private readonly List<StructCSharp> _structs = new();

		public GeneratePlatformInvokeCodeUseCase(string libraryName)
		{
			_cSharpCodeGenerator = new CSharpCodeGenerator(libraryName, _layoutCalculator);
			_codeExplorer.EnumFound += TranspileEnum;
			_codeExplorer.FunctionFound += TranspileFunction;
			_codeExplorer.RecordFound += TranspileRecord;
			_codeExplorer.OpaqueTypeFound += TranspileOpaqueType;
			_codeExplorer.ExternalTypeFound += TranspileExternalType;
		}

		public string GenerateCode(CXTranslationUnit translationUnit, string libraryName, IEnumerable<string>? includeDirectories)
		{
			_codeExplorer.Explore(translationUnit, includeDirectories);

			const string comment = @"
//-------------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by the following tool:
//        https://github.com/lithiumtoast/c2cs
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ReSharper disable All
//-------------------------------------------------------------------------------------

using System;
using System.Runtime.InteropServices;";

			var commentFormatted = comment.TrimStart() + "\r\n";

			var className = Path.GetFileNameWithoutExtension(libraryName);

			var membersBuilder = ImmutableArray.CreateBuilder<MemberDeclarationSyntax>();
			membersBuilder.AddRange(_fields);
			membersBuilder.AddRange(_enums);
			membersBuilder.AddRange(_structs);
			membersBuilder.AddRange(_methods);
			membersBuilder.AddRange(_functionPointers);
			var members = membersBuilder.ToImmutableArray();

			var @class = _cSharpCodeGenerator.CreatePInvokeClass(className, members)
				.WithLeadingTrivia(SyntaxFactory.Comment(commentFormatted));

			return @class
				.Format()
				.ToFullString();
		}

		private void TranspileRecord(CXCursor clangRecord)
		{
			var cSharpStruct = _cSharpCodeGenerator.CreateStruct(clangRecord);
			_structs.Add(cSharpStruct);
		}

		private void TranspileFunction(CXCursor clangFunction)
		{
			var cSharpMethod = _cSharpCodeGenerator.CreateExternMethod(clangFunction);
			_methods.Add(cSharpMethod);
		}

		private void TranspileConstant(CXCursor clangConstant)
		{
			var cSharpConstant = _cSharpCodeGenerator.CreateConstant(clangConstant);
			_fields.Add(cSharpConstant);
		}

		private void TranspileEnum(CXCursor clangEnum)
		{
			var name = clangEnum.Spelling.CString;
			if (string.IsNullOrEmpty(name))
			{
				name = clangEnum.Type.Spelling.CString;
			}

			if (string.IsNullOrEmpty(name))
			{
				clangEnum.VisitChildren(TranspileConstant);
			}
			else
			{
				var cSharpEnum = _cSharpCodeGenerator.CreateEnum(clangEnum);
				_enums.Add(cSharpEnum);
			}
		}

		private void TranspileOpaqueType(CXCursor clangTypedef)
		{
			var cSharpStruct = _cSharpCodeGenerator.CreateOpaqueStruct(clangTypedef);
			_structs.Add(cSharpStruct);
		}

		private void TranspileExternalType(CXCursor clangTypedef)
		{
			var cSharpStruct = _cSharpCodeGenerator.CreateExternalStruct(clangTypedef);
			_structs.Add(cSharpStruct);
		}
	}
}
